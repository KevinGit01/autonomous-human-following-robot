#include "NU32.h"
#include "direction.h"
#include <stdio.h>


#define BUF_SIZE 200
#define NU32_SYS_FREQ 80000000ul


void __ISR(_UART_1_VECTOR, IPL1SOFT) IntUart1Handler(void) {
  char data = 0x0;
  if (IFS0bits.U1RXIF) {       // check if interrupt generated by a RX event
  //  U1TXREG = U1RXREG;         // send the received data out

    while(!U1STAbits.URXDA) { // poll to see if there is data to read in RX FIFO
        ;
    }
    data = U1RXREG;
    if(data == 0x1){
          NU32_LED1 = 0;
    }else{
          NU32_LED1 = 1;
    }

}

      IFS0bits.U1RXIF = 0;       // clear the RX interrupt flag
}

int main(){
  char buffer[BUF_SIZE];
  NU32_Startup();
  NU32_LED1 = 1;
  NU32_LED2 = 1;

  U1MODEbits.BRGH = 0;
  U1BRG = 129;

  // configure TX & RX pins
  U1STAbits.UTXEN = 1;
  U1STAbits.URXEN = 1;

  // configure using RTS and CTS
  U1MODEbits.UEN = 0b00;

  // configure the UART interrupts
  U1STAbits.URXISEL = 0x0; // RX interrupt when receive buffer not empty
  IFS0bits.U1RXIF = 0;     // clear the rx interrupt flag.  for
                           // tx or error interrupts you would also need to clear
                           // the respective flags
  IPC6bits.U1IP = 1;       // interrupt priority
  IEC0bits.U1RXIE = 1;     // enable the RX interrupt

  // turn on UART1
  U1MODEbits.ON = 1;

  while(1){
  //  if(PORTBbits.RB1 == 0){
  //  dir(0);
  ;
    }

  return 0;
}
